#!/bin/sh

. $(dirname $0)/style.sh

HEIGHT=22

c() {
    herbstclient "$@"
}

clients() {
  local n=$(c attr tags.focus.curframe_wcount)
  local c=$(c attr tags.focus.curframe_windex)

  for i in $(seq $n); do
    if [ $(($i - 1)) -eq $c ]; then
      printf -- ' %%{F%s}%s%%{F-} ' $ORANGE $i
    else
      printf -- ' %s ' $i
    fi
  done
}

time() {
  while :; do
    printf -- "time %s %%{F$WHITE}%s%%{F-}\n" $(date +'%Y-%m-%d %H:%M')

    sleep $((60 - $(date +%S)))
  done
}

bat_color() {
  local state=$1
  local perc=$2
  local c=$GREEN

  [ "$perc" -lt 75 ] && c=$YELLOW
  [ "$perc" -lt 50 ] && c=$ORANGE
  [ "$perc" -lt 25 ] && c=$RED
  [ "$state" -eq 1 ] && c=$BLUE

  printf '%s' $c
}

bat() {
  local sys=/sys/class/power_supply
  local ac=$sys/AC
  local bat state now full perc

  [ -d $ac ] || return 0

  while :; do
    state=$(< $ac/online)

    for bat in $sys/BAT*; do
      case $bat in
        *\*)
          return 0
          ;;
      esac

      now=$(< $bat/energy_now)
      full=$(< $bat/energy_full)
      perc=$(expr \( 100 \* $now \) / $full)

      printf -- ' %%{F%s}%s%%{F-}' $(color $state $perc) $perc
    done

    printf -- '\n'

    sleep 5
  done
}

parse() {
  local event msg
  local update prev
  local clients time bat title

  while read -r event msg; do
    update=

    case $event in
      title)
        title="$msg"
        clients=$(clients)
        update=yes
        ;;
      time|bat)
        eval prev=\$$event
        if [ "$prev" != "$msg" ]; then
          eval $event="\$msg"
        fi
        update=yes
        ;;
    esac

    if [ "$update" ]; then
      printf -- ' %s %%{c} %s %%{r} %s %s \n' "$clients" "$title" "$bat" "$time"
    fi
  done
}

trap 'c pad 0 0' INT TERM EXIT
c pad 0 $HEIGHT

{
  (time)&
  TIMEPID=$!
  trap 'kill $TIMEPID' INT TERM EXIT

  (bat)&
  BATPID=$!
  trap 'kill $BATPID' INT TERM EXIT

  local hook arg title
  c --idle | while read -r hook arg title; do
    printf -- 'title %s\n' "$title"
  done
} | parse | lemonbar \
  -g x$HEIGHT++ \
  -f $FONT_BITMAP \
  -F $LIGHT \
  -B $DARK

#!/bin/sh

# TODO: sed-able with @
program_version=0.0.0
datadir=/usr/share/abuild

if ! [ -f "$datadir/functions.sh" ]; then
	echo "$datadir/functions.sh: not found" >&2
	exit 1
fi
. "$datadir/functions.sh"

# defaults
BUILD_BASE="abuild build-base"
ARCHES="x86 x86_64"
NAME_PREFIX="acontain"
MIRROR="http://nl.alpinelinux.org/alpine"

: ${SUDO:="sudo"}
: ${SUDO_APK:="abuild-apk"}

_create() {
	local name=$1
	local release=$2
	local arch=$3
	local rootfs=$4

	if ! _lxc info -n $name >/dev/null 2>&1; then
		msg "$name: creating"
		_lxc create \
			-n $name \
			-t alpine \
			-- \
			-r $MIRROR/$(_version $release)/main \
			-a $arch \
			$BUILD_BASE
	fi

	local p
	for p in $BUILD_BASE; do
		if ! $SUDO grep -q "^$p\$" $rootfs/etc/apk/world; then
			msg "$name: installing $p"
			$SUDO_APK add --root $rootfs $p
		fi
	done

	local mnt=lxc.mount.entry=$APORTSDIR
	if ! $SUDO grep -q ^$mnt $rootfs/../config; then
		msg "$name: adding bind mount to $APORTSDIR"
		$SUDO sh -c \
			"echo '$mnt home/abuild/aports none bind,create=dir 0 0' \
			>> $rootfs/../config"
	fi
}

_prepare() {
	local name=$1
	local release=$2
	local arch=$3
	local rootfs=$4

	if ! $SUDO grep -q ^abuild: $rootfs/etc/passwd; then
		msg "$name: adding abuild user"
		_lxc attach -n $name -- \
			/usr/sbin/adduser -D -G abuild -s /bin/sh abuild
	fi

	local sudoers=$rootfs/etc/sudoers.d/abuild
	if ! $SUDO test -e $sudoers; then
		msg "$name: configuring sudo"
		$SUDO sh -c "echo 'abuild ALL=NOPASSWD: ALL' > $sudoers"
	fi

	if ! $SUDO test -e $rootfs/home/abuild/.abuild/abuild.conf; then
		msg "$name: generating keys"
		_lxc attach -n $name -- su - abuild -c 'echo | abuild-keygen -ai'
	fi
}

_upgrade() {
	local name=$1
	local release=$2
	local arch=$3
	local rootfs=$4

	$SUDO_APK upgrade --root $rootfs -U
}

_ls() {
	local name=$1

	msg "$name:"
	_lxc info -n $name | grep -v "^Name:"
}

_change_state() {
	local name=$1
	local action=$2
	local needs=$3

	_lxc info -n $name 2>/dev/null | grep -q $needs || return 0

	msg "$name: ${action}ing"
	_lxc $action -n $name
}

_start() {
	_change_state $1 start STOPPED
}

_stop() {
	_change_state $1 stop RUNNING
}

destroy() {
	stop
	_foreach_container _destroy
}

_destroy() {
	_change_state $1 destroy STOPPED
}

build() {
	_BUILD_ARGS="$@"
	_foreach_container _build
}

_build() {
	local name=$1
	local release=$2


	[ "$(_release)" = "$release" ] || return 0

	local d=$(pwd)
	d=${d##*$APORTSDIR}
	case $d in
		/*)
			d=${d#*/}
			;;
	esac

	msg "$name: build $d"


	_lxc attach -n $name -- su - abuild -c \
		"cd aports/$d && abuild \"$_BUILD_ARGS\""
}

console() {
	while [ "$_ENTER_SEL" != 0 ]; do
		msg "Select:"
		_ENTER_N=0
		_foreach_container _console_ls
		read -r _ENTER_SEL
		_ENTER_N=0
		_foreach_container _console_attach
	done
}

_console_ls() {
	local name=$1
	_ENTER_N=$(($_ENTER_N+1))

	printf "%3s: %s\n" $_ENTER_N $name
}

_console_attach() {
	local name=$1
	_ENTER_N=$(($_ENTER_N+1))

	[ "$_ENTER_N" = "$_ENTER_SEL" ] || return 0

	_ENTER_SEL=0

	_lxc console -n $name
}

_branches() {
	git for-each-ref --format='%(refname:short)' refs/heads |
		grep -e '^master$' -e '[0-9.]-stable$'
}

_branch() {
	git rev-parse --abbrev-ref HEAD
}

_foreach_container() {
	local cb=$1
	local r a n

	for r in $(_releases); do
		for a in $ARCHES; do
			n=$NAME_PREFIX-$r-$a
			eval $1 $n \$r \$a $(_lxc_path)/$n/rootfs
		done
	done
}

_releases() {
	_branches | _branch_to_release
}

_release() {
	_branch | _branch_to_release
}

_branch_to_release() {
	sed 's|^master$|edge|;s|-stable$||'
}

_version() {
	echo "$@" | sed 's|^\([0-9]\)|v\1|'
}

_lxc_path() {
	_lxc config lxc.lxcpath
}

_lxc() {
	local action=$1
	shift

	[ "$action" = attach ] && _chroot_caps 0

	$SUDO env -i lxc-$action "$@"

	[ "$action" = attach ] && _chroot_caps 1
}

_chroot_caps() {
	local f=/proc/sys/kernel/grsecurity/chroot_caps

	[ -e $f ] || return 0

	$SUDO sh -c "echo $1 >$f"
}

_verify() {
	[ "$APORTSDIR" ] || die "can't locate \$APORTSDIR"
	git rev-parse 2>/dev/null || die "not in a git tree"
}

_usage() {
	cat >&2 <<-EOF
	$program $program_version
	usage: $program <command>

	Commands:
	 create   create lxc containers for every branch/arch
	 prepare  configure running containers for building
	 upgrade  upgrade running containers
	 ls       list status of created containers
	 start    start all stopped containers
	 stop     stop all running containers
	 destroy  stop and destroy all containers
	 build    run abuild for all archs in containers matching
	          the current git branch
	 console  attach to the console of the selected container
	
	Example:
	 cd \$APORTSDIR
	 git co master
	 git co 3.2-stable
	 git co 3.1-stable
	 $program create
	 $program start
	 $program prepare
	 cd main/openssl
	 $program build -r
	 $program stop
	EOF
}

_verify

cmd=$1
shift

case $cmd in
	create|prepare|upgrade|ls|start|stop)
		_foreach_container _$cmd "$@"
		;;
	destroy|build|console)
		$cmd "$@"
		;;
	*)
		_usage
		;;
esac

#!/bin/sh

# TODO: sed-able with @
program_version=0.0.0
datadir=/usr/share/abuild

if ! [ -f "$datadir/functions.sh" ]; then
	echo "$datadir/functions.sh: not found" >&2
	exit 1
fi
. "$datadir/functions.sh"

# defaults
BUILD_BASE="abuild build-base"
ARCHES="x86 x86_64"
NAME_PREFIX="acontain"
MIRROR="http://nl.alpinelinux.org/alpine"

: ${SUDO:="sudo"}
: ${SUDO_APK:="abuild-apk"}

create() {
	_foreach_container _create
}

_create() {
	local name=$1
	local release=$2
	local arch=$3
	local rootfs=$4

	if ! _lxc info -n $name >/dev/null 2>&1; then
		msg "$name: creating"
		_lxc create \
			-n $name \
			-t alpine \
			-- \
			-r $MIRROR/$(_version $release)/main \
			-a $arch \
			$BUILD_BASE
	fi

	local p
	for p in $BUILD_BASE; do
		if ! $SUDO grep -q "^$p\$" $rootfs/etc/apk/world; then
			msg "$name: installing $p"
			$SUDO_APK add --root $rootfs $p
		fi
	done
}

prepare() {
	_foreach_container _prepare
}

_prepare() {
	local name=$1
	local release=$2
	local arch=$3
	local rootfs=$4

	if ! $SUDO grep -q ^abuild: $rootfs/etc/passwd; then
		msg "$name: adding abuild user"
		_lxc attach -n $name -- /usr/sbin/adduser -D -G abuild -s /bin/sh abuild
	fi

	local sudoers=$rootfs/etc/sudoers.d/abuild
	if ! [ -e $sudoers ]; then
		msg "$name: configuring sudo"
		$SUDO sh -c "echo 'abuild ALL=NOPASSWD: ALL' > $sudoers"
	fi

	_lxc attach -n $name -- su - abuild -c 'yes | abuild-keygen -ai'
}

upgrade() {
	_foreach_container _upgrade
}

_upgrade() {
	local name=$1
	local release=$2
	local arch=$3
	local rootfs=$4

	$SUDO_APK upgrade --root $rootfs -U
}

ls() {
	_foreach_container _ls
}

_ls() {
	local name=$1

	msg "$name:"
	_lxc info -n $name | grep -v "^Name:"
}

start() {
	_foreach_container _start
}

_start() {
	local name=$1

	_lxc info -n $name 2>/dev/null | grep -q STOPPED || return 0

	msg "$name: starting"
	_lxc start -n $name
}

stop() {
	_foreach_container _stop
}

_stop() {
	local name=$1

	_lxc info -n $name 2>/dev/null | grep -q RUNNING || return 0

	msg "$name: stopping"
	_lxc stop -n $name
}

destroy() {
	stop
	_foreach_container _destroy
}

_destroy() {
	local name=$1

	_lxc info -n $name 2>/dev/null | grep -q STOPPED || return 0

	msg "$name: destroying"
	_lxc destroy -n $name
}

enter() {
	while [ "$_ENTER_SEL" != 0 ]; do
		msg "Select:"
		_ENTER_N=0
		_foreach_container _enter_ls
		read -r _ENTER_SEL
		_ENTER_N=0
		_foreach_container _enter_attach
	done
}

_enter_ls() {
	local name=$1
	_ENTER_N=$(($_ENTER_N+1))

	printf "%3s: %s\n" $_ENTER_N $name
}

_enter_attach() {
	local name=$1
	_ENTER_N=$(($_ENTER_N+1))

	[ "$_ENTER_N" = "$_ENTER_SEL" ] || return 0

	_ENTER_SEL=0

	_lxc console -n $name
}

_branches() {
	git for-each-ref --format='%(refname:short)' refs/heads |
		grep -e '^master$' -e '[0-9.]-stable$'
}

_foreach_container() {
	local cb=$1
	local r a n

	for r in $(_releases); do
		for a in $ARCHES; do
			n=$NAME_PREFIX-$r-$a
			eval $1 $n \$r \$a $(_lxc_path)/$n/rootfs
		done
	done
}

_releases() {
	_branches | sed 's|^master$|edge|;s|-stable$||'
}

_version() {
	echo "$@" | sed 's|^\([0-9]\)|v\1|'
}

_lxc_path() {
	_lxc config lxc.lxcpath
}

_lxc() {
	local action=$1
	shift

	[ "$action" = attach ] && _chroot_caps 0

	$SUDO env -i lxc-$action "$@"

	[ "$action" = attach ] && _chroot_caps 1
}

_chroot_caps() {
	local f=/proc/sys/kernel/grsecurity/chroot_caps

	[ -e $f ] || return 0

	$SUDO sh -c "echo $1 >$f"
}

_verify() {
	[ "$APORTSDIR" ] || die "can't locate \$APORTSDIR"
	git rev-parse 2>/dev/null || die "not in a git tree"
}

_usage() {
	cat >&2 <<-EOF
	$program $program_version
	usage: $program <command>

	Commands:
	 create  create lxc containers for every branch
	EOF
}

_verify

cmd=$1
shift

case $cmd in
	create|prepare|upgrade|ls|start|stop|destroy|enter)
		$cmd "$@"
		;;
	*)
		_usage
		;;
esac
